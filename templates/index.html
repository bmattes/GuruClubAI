<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --primary-color: #0070c9;
      --background-color: #f8f8f8;
      --border-color: #e0e0e0;
      --shadow-color: rgba(0, 0, 0, 0.1);
      --highlight-color: #ffcc00;
      --accent-red: #e74c3c;
      --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --transition-duration: 0.3s;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      font-family: var(--font-family);
      background-color: var(--background-color);
      color: #333;
    }
    
    /* 2x2 grid that fills the viewport */
    .meeting-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      width: 100vw;
      height: 100vh;
    }
    
    /* Chat box (participant) styling */
    .participant {
      background-color: #fff;
      border: 1px solid var(--border-color);
      border-radius: 16px;
      margin: 10px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 4px 8px var(--shadow-color);
      transition: box-shadow var(--transition-duration);
      position: relative;
    }
    .participant:hover {
      box-shadow: 0 6px 12px var(--shadow-color);
    }
    .participant.highlight {
      border-color: var(--highlight-color);
      box-shadow: 0 0 10px var(--highlight-color);
    }
    
    .avatar {
      background: linear-gradient(135deg, var(--primary-color), #005fa3);
      color: #fff;
      font-size: 48px;
      text-align: center;
      padding: 16px;
    }
    
    .name {
      background: #f0f0f0;
      font-weight: bold;
      text-align: center;
      padding: 8px;
      font-size: 18px;
    }
    
    .messages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      font-size: 16px;
      text-align: center;
    }
    
    /* Integrated User Controls (in the User chat box) */
    #user-controls {
      padding: 8px;
      background-color: #fafafa;
      border-top: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #user-controls input[type="text"] {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      transition: border var(--transition-duration);
    }
    #user-controls input[type="text"]:focus {
      outline: none;
      border-color: var(--primary-color);
    }
    /* Button row for Raise Hand, Record, and Question */
    #user-button-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }
    /* Small square buttons for Raise Hand and Question */
    #handButtonUser,
    #questionButtonUser {
      width: 40px;
      height: 40px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      background: #eee;
      transition: background var(--transition-duration);
      cursor: pointer;
      flex: none;
    }
    #handButtonUser:hover,
    #questionButtonUser:hover {
      background: #ddd;
    }
    /* Large red Record button in the center */
    #recordButtonUser {
      background-color: var(--accent-red);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 70px;
      height: 70px;
      font-size: 18px;
      transition: background-color var(--transition-duration);
      cursor: pointer;
      flex: none;
    }
    #recordButtonUser:hover {
      background-color: #c0392b;
    }
    
    /* Hide any old bottom controls */
    .chat-controls {
      display: none;
    }
    
    /* Optional scrollbar styling for messages */
    .messages::-webkit-scrollbar {
      width: 6px;
    }
    .messages::-webkit-scrollbar-track {
      background: #f0f0f0;
    }
    .messages::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 3px;
    }
  </style>
</head>
<body>

  <!-- Intro Modal Overlay for Username -->
  <div id="introModal" style="
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
  ">
    <h2 style="font-size: 28px; margin-bottom: 20px;">Welcome to Guru Club</h2>
    <p style="font-size: 18px; margin-bottom: 20px;">Please enter your name:</p>
    <input type="text" id="introNameInput" placeholder="Your Name" style="font-size: 24px; padding: 10px; width: 80%; max-width: 300px; margin-bottom: 20px;">
    <button id="introSubmitButton" style="font-size: 24px; padding: 10px 20px; background: var(--primary-color); color: white; border: none; border-radius: 8px; cursor: pointer;">Continue</button>
  </div>
  
  <div class="meeting-container">
    <!-- User Chat Box (Top Left) -->
    <div class="participant" id="participant-user">
      <div class="avatar" id="avatar-user">You</div>
      <div class="name" id="name-user">You</div>
      <div class="messages" id="messages-user"></div>
      <!-- Integrated user controls: text input and button row -->
      <div id="user-controls">
        <input type="text" id="userInput" placeholder="Type your message..." />
        <div id="user-button-row">
          <button id="handButtonUser" title="Raise Hand">✋</button>
          <button id="recordButtonUser">Record</button>
          <button id="questionButtonUser" title="Ask a Question">?</button>
        </div>
      </div>
    </div>
    
    <!-- Sophia Chat Box (Top Right) -->
    <div class="participant" id="participant-Sophia">
      <div class="avatar" id="avatar-Sophia">S</div>
      <div class="name" id="name-Sophia">Sophia</div>
      <div class="messages" id="messages-Sophia"></div>
    </div>
    
    <!-- Rex Chat Box (Bottom Left) -->
    <div class="participant" id="participant-Rex">
      <div class="avatar" id="avatar-Rex">R</div>
      <div class="name" id="name-Rex">Rex</div>
      <div class="messages" id="messages-Rex"></div>
    </div>
    
    <!-- Ella Chat Box (Bottom Right) -->
    <div class="participant" id="participant-Ella">
      <div class="avatar" id="avatar-Ella">E</div>
      <div class="name" id="name-Ella">Ella</div>
      <div class="messages" id="messages-Ella"></div>
    </div>
  </div>
  
  <script>
    
    // Global audio player element—reuse this for all TTS playback.
    const audioPlayer = new Audio();


    // --- New: Front-End Conversation Manager ---
    // This function replicates the back-end conversation_manager.
    function conversation_manager(query) {
      let agents = ["Sophia", "Rex", "Ella"];
      if (query && query.trim().length > 0) {
        let lowered = query.toLowerCase();
        let addressed = [];
        agents.forEach(agent => {
          if (lowered.indexOf(agent.toLowerCase()) !== -1) {
            addressed.push(agent);
          }
        });
        return addressed.concat(agents.filter(a => addressed.indexOf(a) === -1));
      }
      return agents;
    }

    // --- Global Variables & Element References ---
    let currentUserName = "user_1"; // We'll ask for the username every time.
    const conversationHistory = [];
    
    // Global variables for audio skip functionality.
    let currentAudio = null;
    let currentAudioResolve = null;
    let currentAgentName = null;
    
    // Global flag for raised hand.
    let handRaised = false;
    
    // --- Helper Functions ---
    function clearAllHighlights() {
      ["user", "Sophia", "Rex", "Ella"].forEach(participant => {
        document.getElementById("participant-" + (participant === "user" ? "user" : participant)).classList.remove("highlight");
      });
    }
    
    function setParticipantMessage(participant, content, turn_id) {
      const pane = document.getElementById("messages-" + (participant === "user" ? "user" : participant));
      pane.innerHTML = "";
      if (content) {
        const div = document.createElement("div");
        div.className = "message";
        if (turn_id !== undefined) {
          div.innerHTML = `<span class="debug-id">[Turn ${turn_id}]</span> ${content}`;
        } else {
          div.textContent = content;
        }
        pane.appendChild(div);
        // Append a small Insight button.
        const insightButton = document.createElement("button");
        insightButton.textContent = "+1";
        insightButton.style.fontSize = "10px";
        insightButton.style.marginLeft = "10px";
        insightButton.addEventListener("click", function(e) {
          e.stopPropagation();
          giveInsight(currentUserName, (participant === "user") ? currentUserName : participant);
        });
        pane.appendChild(insightButton);
      }
    }
    
    function clearMessageForParticipant(participant) {
      document.getElementById("messages-" + (participant === "user" ? "user" : participant)).innerHTML = "";
    }
    
    async function getProfile() {
      // Placeholder for profile updates.
    }
    
    const agentVoices = {
      "Sophia": "XB0fDUnXU5powFXDhCwa",
      "Rex": "TX3LPaxmHKxFdv7VOQHJ",
      "Ella": "XrExE9yKIg1WjnnlVkGX"
    };
    
    function setupSkipEventListeners() {
      const agents = ["Sophia", "Rex", "Ella"];
      agents.forEach(agent => {
        const elem = document.getElementById("participant-" + agent);
        if (elem) {
          elem.addEventListener("click", function() {
            if (currentAudio && currentAgentName === agent) {
              console.log("Skip triggered for", agent);
              currentAudio.pause();
              currentAudio.currentTime = currentAudio.duration;
              if (currentAudioResolve) {
                currentAudioResolve();
                currentAudioResolve = null;
              }
              clearAllHighlights();
              clearMessageForParticipant(agent);
              currentAudio = null;
              currentAgentName = null;
            }
          });
        }
      });
    }
    setupSkipEventListeners();
    
    async function playAudioForAgent(replyObj) {
        const cleanReply = replyObj.content.replace(/^\s*\[TO:[^\]]+\]\s*/, "");
        const voice_id = agentVoices[replyObj.name] || "default_voice_id";
        console.log("Calling /api/tts for", replyObj.name, "with text:", cleanReply, "and voice_id:", voice_id);

        try {
        const response = await fetch("/api/tts", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: cleanReply, voice_id: voice_id })
        });
        if (response.ok) {
          const blob = await response.blob();
          console.log("Received blob for", replyObj.name, "with size:", blob.size);
          const audioUrl = URL.createObjectURL(blob);
          
          // Instead of creating a new Audio object, use the global audioPlayer.
          audioPlayer.src = audioUrl;
          // (Optionally, you can call audioPlayer.load();)
          
          // Set globals to track which agent is currently playing.
          currentAudio = audioPlayer;
          currentAgentName = replyObj.name;
          
          // Create a promise that resolves when playback ends.
          const playPromise = new Promise((resolve) => {
            audioPlayer.onended = () => {
              console.log("Finished playing audio for", replyObj.name);
              clearAllHighlights();
              clearMessageForParticipant(replyObj.name);
              resolve();
            };
          });
          
          // Attempt to play the audio.
          await audioPlayer.play().catch(error => {
            console.error("Audio.play() rejected for", replyObj.name, error);
          });
          
          await playPromise;
          
          // Clear the globals.
          currentAudio = null;
          currentAgentName = null;
          return;
        } else {
          console.error("TTS API error for", replyObj.name, response.statusText);
        }
        } catch (error) {
        console.error("Error in TTS call for", replyObj.name, error);
        }
        }

    
    // --- New: Sequential Agent Reply Handling ---
    async function handleAgentResponses(force_question = false) {
      // Get the most recent user message from conversationHistory.
      let lastUserMessage = "";
      for (let i = conversationHistory.length - 1; i >= 0; i--) {
        if (conversationHistory[i].role === "user") {
          lastUserMessage = conversationHistory[i].content;
          break;
        }
      }
      
      // If forcing a question, choose one agent at random; otherwise, use the conversation_manager
      // with the user's message to set the agent order.
      let agentsToReply = force_question 
          ? [randomChoice(["Sophia", "Rex", "Ella"])]
          : conversation_manager(lastUserMessage);
      
      // Loop through each agent in order.
      for (let i = 0; i < agentsToReply.length; i++) {
        const agent = agentsToReply[i];
        const payload = {
          user_id: currentUserName,
          conversation_history: conversationHistory,
          agent: agent,
          force_question: force_question
        };
        try {
          const response = await fetch("/api/agent_reply", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          const data = await response.json();
          const reply = data.reply;
          // Append the agent's reply to the conversation history.
          conversationHistory.push({ role: "assistant", name: agent, content: reply });
          // Update UI: display the reply and highlight the agent's chat box.
          setParticipantMessage(agent, reply);
          document.getElementById("participant-" + agent).classList.add("highlight");
          // Chain the audio playback.
          await playAudioForAgent({ name: agent, content: reply });
          clearAllHighlights();
        } catch (error) {
          console.error("Error handling reply for agent", agent, error);
        }
      }
    }

    
    // Helper to choose a random element from an array.
    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    
    // --- Updated sendMessage Function ---
    async function sendMessage(message, extraPayload = {}) {
      const payload = {
        user_id: currentUserName,
        user_message: message,
        conversation_history: conversationHistory,
        ...extraPayload
      };
      try {
        // Append the user message to conversationHistory.
        conversationHistory.push({ role: "user", content: message });
        // Clear all participant message boxes.
        clearMessageForParticipant("user");
        clearMessageForParticipant("Sophia");
        clearMessageForParticipant("Rex");
        clearMessageForParticipant("Ella");
        // Update the user chat box with the new message.
        setParticipantMessage("user", message);
        // Sequentially fetch and play agent replies.
        await handleAgentResponses(extraPayload.force_question || false);
        // Clear all highlights, then highlight the user box.
        clearAllHighlights();
        document.getElementById("participant-user").classList.add("highlight");
        getProfile();
      } catch (error) {
        console.error("Error sending message:", error);
      }
    }
    
    // --- Event Listeners for User Input ---
    document.getElementById("userInput").addEventListener("keydown", function(e) {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        const message = this.value.trim();
        if (message) {
          sendMessage(message);
          this.value = "";
        }
      }
    });
    
    // --- Speech Recognition Setup ---
    function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    }
    
    let recognition;
    if ("webkitSpeechRecognition" in window) {
      console.log("webkitSpeechRecognition available, using it.");
      recognition = new webkitSpeechRecognition();
      recognition.lang = "en-US";
    } else if ("SpeechRecognition" in window) {
      console.log("Using SpeechRecognition.");
      recognition = new SpeechRecognition();
      recognition.lang = "en-US";
    } else {
      console.error("Speech Recognition not supported.");
    }
    
    let isRecognizing = false;
    if (recognition) {
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = "en-US";
      
      let finalTranscript = "";
      let latestInterim = "";
      
      recognition.onstart = function() {
        console.log("Speech recognition started.");
        isRecognizing = true;
      };
      
      recognition.onresult = function(event) {
        latestInterim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          let transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript;
          } else {
            latestInterim += transcript;
          }
        }
        console.log("Interim transcript:", latestInterim);
        console.log("Final transcript so far:", finalTranscript);
      };
      
      recognition.onerror = function(event) {
        console.error("Speech recognition error:", event.error);
      };
      
      recognition.onend = function() {
        console.log("Speech recognition ended.");
        isRecognizing = false;
        let transcriptToSend = finalTranscript || latestInterim;
        console.log("Transcript to send:", transcriptToSend);
        if (transcriptToSend) {
          sendMessage(transcriptToSend);
        }
        finalTranscript = "";
        latestInterim = "";
      };
      
      document.getElementById("recordButtonUser").addEventListener("click", function() {
        if (recognition) {
          if (isRecognizing) {
            console.log("Stopping recording...");
            recognition.stop();
          } else {
            console.log("Starting recording...");
            recognition.start();
          }
        }
      });
    }
    
    // --- Event Listener for the Question Button ---
    document.getElementById("questionButtonUser").addEventListener("click", function() {
      console.log("Question button pressed (User box).");
      handRaised = false;
      clearAllHighlights();
      document.getElementById("participant-user").classList.add("highlight");
      // Force a question by sending an empty message with force_question flag.
      sendMessage("", { force_question: true });
      setTimeout(() => { this.classList.remove("highlight"); }, 1000);
    });
    
    // --- Intro Modal Logic ---
    window.addEventListener("load", function() {
      document.getElementById("introModal").style.display = "flex";
    });
    
    document.getElementById("introSubmitButton").addEventListener("click", function() {
      const nameInput = document.getElementById("introNameInput").value.trim();
      if (nameInput) {
        currentUserName = nameInput;
        document.getElementById("name-user").textContent = nameInput;
        document.getElementById("introModal").style.display = "none";
      } else {
        alert("Please enter a valid name.");
      }
    });
    
    document.getElementById("introNameInput").addEventListener("keydown", function(e) {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        document.getElementById("introSubmitButton").click();
      }
    });
  </script>
</body>
</html>
